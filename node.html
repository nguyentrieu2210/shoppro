<!-- React là frontend để nó chạy được thì nó cần con server (nó lấy thằng node làm con server) -->

<!-- 
    => node_modules là bao gồm các package để khởi động con server đó (là nơi chứa bộ xả và các package mà ta sẽ cài trong tương lai) ==> Ứng dụng react là chạy được thì phải có thư mục node_modules
    => react khi chúng ta code có thể sẽ phải cài thêm package ngoài, và khi chúng ta cài xong thì cái bộ xả của nó lại xả vào trong node 
    => khi ta cài 1 package nào đó thì tên của package sẽ được lưu vào thư mục package.json bộ xả thì nó xả vào thư mục node_modules
    => nếu chúng ta muốn di chuyển source code của chúng ta đi đâu thì đừng di chuyển thư mục node_modules vì chúng ta chỉ cần thư mục package.json là đủ rồi
    ==> khi ta sang môi trường mới ta chỉ cần bật npm lên và gõ câu lệnh npm install thì toàn bộ package nằm trong package.json sẽ được cài đặt và nó sẽ xả ra cho ta thư mục node_modules mới giống như thư mục node_modules cũ
    (vì trong thư mục node_modules có hàng triệu file nên thao tác bằng copy hay kéo rất lâu) 
-->

<!-- 
    public là thư mục để chứa các file data tĩnh (data tĩnh là các file không chứa giải thuật gì cả, dữ liệu là các file mà dữ liệu không thay đổi vd như ảnh, html, css, js) 
-->

<!-- 
    src là viết tắt của từ source. vì thế tất cả giải thuật, tất cả các file xây dựng lên ứng dụng react sẽ ở trong  
-->

<!-- 
    ReactDom.render(.. , ..) cho phép ta đổ data vào bất cứ đâu (có hai tham số): 
    ==> tham số thứ nhất là đổ data (không cần dấu nháy, viết html như bình thường) ==> trong trường hợp nhiều dòng html thì ta viết nó ra ngoài gán với 1 biến rồi gọi lại nó vào 
    ==> tham số thứ hai là đổ vào đâu  
-->

<!-- từ h ta sẽ code trong index.js mà không cần quan tâm tới index.html nữa  -->
<!-- 
    => Cái gì không thay đổi thì mình dùng const
    => Cái gì nó thay đổi thì dùng let
    => Rất ít khi dùng var (chỉ những cái nào nó xuất hiện trong nhiều block code) 
-->

<!-- ctrl C để tắt server  -->

<!-- Đường dẫn chạy là localhost:3000 -->

<!-- Để tạo vùng làm việc của js vào trong html (nhúng js) ta sử dụng cặp dấu ngoặc nhọn {...} ==> trong đây muốn gọi hàm thì ta phải làm theo luật của js (vd: -- {nameFunction()} --) -->

<!-- 
    Vì trong frontend giải thuật đơn giản nên nó sẽ không có cấu trúc if else mà ta sẽ sử dụng toán tử 3 ngôi 
    ==> sau này mà muốn kiểm tra cái gì thì ta chỉ sử dụng toán tử 3 ngôi 
-->

<!-- js thì nó chỉ cho phép cấu trúc html chỉ có 1 thằng cha duy nhất ==> để fix lỗi này ta sử dụng cặp thẻ <>...</> -->

<!-- Điều quan trọng nhất của component là có thể sử dụng lại -->

<!-- 
    => component được khai báo ở dạng function và tên khai báo PHẢI viết hoa những chứ cái đầu và bắt buộc phải có return
    vd: 
    const App = () => {
        return (
            ...
        );
    }
    ReactDom.render(<App/>, document.getElementById("root")); 
    Lưu ý: chỉ cho vào được 1 thằng 
    => Để gọi 1 component vào ReactDom.render hay gọi vào 1 component khác ta sử dụng <.../>
    => Không ai lại viết 2 component trong 1 file cả ==> chúng ta chia component thành các file riêng (để sử dụng được ta viết câu lệnh export default NamComponent)
    => Muốn sử dụng ở đâu thì ta sử dụng luôn vào chỗ đó (nó sẽ tự động import vào )
-->

<!-- 
    => Sẽ có rất nhiều component nên chúng ta sẽ có 1 file để xử lý tất cả các component (App.js)
    => Tất cả các component sẽ được để đặt trong 1 thư mục có tên là components và sẽ được định nghĩa rồi import và App.js để nó xử lý
    vd: 1 component: 
        const Title = () {
            return (...);
        }
        export default Title;
    vd: App.js muốn xử lý ==> <Title/> (nó sẽ tự động import)
    => index.js là file chạy chính chứ không phải file xử lý chính ==> ReactDom.render(<App/>, document.getElementById("root"))
    => Khi làm thực tế thì ta chỉ xử lý cáccomponent và bên App   
-->

<!-- 
    Khi ta lấy giao diện html để làm việc với react thì có 1 số chú ý như sau:
    => trong class ==> className
    => thẻ đơn phải có dấu đóng (vd: <br/>) 
-->

<!-- 
    Trong react giá trị sẽ được lưu vào hai thằng là biến và state
    => Nếu tính toán thông thường thì lưu vào biến
    => Nếu 1 một sự kiện nào đó mà làm thay đổi giá trị của nó thì lưu vào state 
-->

<!-- 
    Nếu ta muốn truyền dữ liệu từ con này sang con kia thì tất cả giá trị sẽ được lưu vào đối tượng props (nó luôn luôn tồn tại)
    => Bên truyền khai báo trong thẻ mở ..key = {..value} (nên đặt tên key trùng với value để dễ kiểm soát)
    => Bên thẻ nhận {key} 
-->

<!-- 
    Destructing trong ES6:
    Vd:
    const obj = {
        a: "html",
        b: "css",
        c: "ruby"
    }
    const {a, b} = obj;
    Khi đó a sẽ nhận giá trị là "html"
       b sẽ nhận giá trị là "css" 
       Lưu ý: phải viết đúng tên muốn lấy
-->

<!-- 1 thẻ thì có thể có nhiều thuộc tính (mỗi thuộc tính cách nhau 1 khoảng trắng) -->

<!-- 
    Trong React khi ta gọi 1 hàm trong phần xử lý sự kiện 
    => Không Có tham số đầu vào thì ta có thể viết dưới dạng hàm như sau  (vd: onClick={NameFunction} 
    => Có tham số đầu vào thì ta có thể viết dưới dạng hàm như sau  (vd: onClick={()=>NameFunction(...)} 
    =>Trong Form Có tham số đầu vào thì ta có thể viết dưới dạng hàm như sau  (vd: onClick={(e)=>NameFunction(...)}  
-->


<!-- 
    Trong React form luôn có 1 thằng lưu lại tất cả các sự kiện mà người dùng thao tác với form là event và thường được đặt tên là e 
        ==> e.target (đích đến là cái thẻ mà ta vừa thao tác) 
        ==> e.target. ... (thuộc tính mà ta muốn lấy vd: e.target.value)
    => Khi truyền tham số đầu vào 1 hàm ở trong form thì bắt buộc phải là tham số thứ 2, bởi vì tham số thứ nhất luôn là event
        ==> hàm khi gọi: (e) => nameFunction(e, ..(2)..)  
-->


<!-- 
    Map chuyên để duyệt mảng (đã mảng thì duyệt map, đã map thì duyệt mảng) ==> duyệt để biểu diễn dữ liệu
    - Sử dụng: ==>  nameArray.map((value, index)=>...);
    Map nhận vào 2 tham số:
    - Tham số thứ nhất ==> Giá trị của phần tử mà nó duyệt qua
    - Tham số thứ hai ==> vị trí phần tử mà nó duyệt qua 
    - Sau dấu mũi tên là phần trả về  
-->


<!-- 
Ngày xưa:
    LIFECIRCLE: là vòng đời của 1 component từ khi nó bắt đầu cho tới khi nó kết thúc
    => vòng đời gồm 3 giải đoạn là: Mounting ==> Updating ==> Unmounting
    => Theo chiều ngang có 3 trạng thái
    => Theo chiều dọc có 2 trạng thái là trước và sau render
    => Bắt đầu là khi component đó được tải lên lần đầu tiên(Mounting) ==> Sau đó có thể sẽ được cập nhật theo state (Updating) và kết thúc là khi ta loại bỏ bỏ nó khỏi cấu trúc html (Unmounting)
    => contructor thường để triệu gọi các thư viện và khởi tạo các giá trị ban đầu
    => Muốn làm cái popup khi chương trình vừa chạy chưa kịp tải giao diện lên mà nó đã hiển thị ==> ta cho vào getDerivedStateFromProps
    vd: ta muốn làm cái popup (khi giao diện được tải lên 1 cái thì popup sẽ tự động chạy) ==> ta cho vào componentDidMount

Bây giờ:
    HOOK: (đặc điểm là tự động chạy)
    => Tất cả phương thức mà nó có từ use thì đều là hook
    => hook componentDidMount tự động thực thi khi component được tải lên lần đầu tiên sau khi đã render xong hoàn toàn ra giao diện
    => Hook componentDidUpdate tự động thực thi khi component lần đầu thay đổi State và đã render xong hoàn toàn ra giao diện
    => Cứ mỗi khi State thay đổi giá trị thì component được reload và chỉ reload giá trị của con nào thay đổi giá trị ==> giúp cho trang web nhanh hơn thay vì reload lại tất cả component
    => Ta sử dụng useEffect để build các hook 
        useEffect(()=>{
        ...
        }, [])
    => Tham số thứ nhất ta có thể viết bất cứ thứ gì 
    => Tham số thứ hai là giá trị bất kì (khi tham thứ hai này thay đổi giá trị thì nó mới chạy lần thứ hai)
    Lưu ý: tham số thứ nhất được quyết định bởi tham số thứ hai (nếu tham số thứ hai thay đổi giá trị thì tham số thứ nhất mới được chạy)
-->

<!-- 
    Nếu muốn lọc ra 1 thằng thì dùng document.getElementById("");
    Nếu muốn lọc ra 1 nhóm thì dùng document.getElementByTabName("");
-->

<!-- 
    Các bước để xử lý 1 nội dung mà người dùng có thể sửa (không phải là xóa) 
    - B1: Đầu tiên nó sẽ ở trạng thái 1 là 1 thẻ khối (vd: p, h,...) và sau khi người dùng kích chọn nó sẽ chuyển sang trạng thái 2 là 1 thẻ input
        => Ở đây ta sẽ xử lý bằng các sử dụng giá trị true vs false và lưu vào 1 biến State (và sử dụng 1 hàm để cập nhật lại giá trị của nó mỗi khi được gọi tới setName(!name))
            + Nếu là true: hiển thị trạng thái 1 (trạng thái ban đầu)
            + Nếu là false: hiển thị trạng thái 2
        => Khi người dùng Click chọn ta sẽ bắt sự kiện onClick ở trạng thái 1 và gọi hàm cập nhật trạng thái (khi đó sẽ hiển thị trạng thái 2)
        => Khi người dùng click ra bên ngoài ta sẽ bắt sự kiện onBlur ở trạng thái 2 và gọi hàm cập nhật trạng thái (khi đó sẽ hiển thị trạng thái 1)
    - B2: Khi người dùng thay đổi nội dung
        => Ở đầy ta bắt sự kiện onChange và 1 biến State để lưu lại những thay đổi nội dung của người dùng (và viết 1 hàm để cập nhật lại nội dung)
    - B3: Khi người dùng bấm Enter nội dung thay đổi sẽ được lưu và chuyển sang trạng thái 1
        => Ở đây ta bắt sự kiện onKeyUp và viết 1 hàm checkEnter bằng cách so sánh kí tự vửa được bấm xuống với enter (vd: e.keyCode===13) thì gọi hàm cập nhật trạng thái
    - B4: Fix 1 số lỗi 
        => Khi người dùng click vào nội dung muốn sửa (đang ở trạng thái 1) thì phải ngay lập tức (trạng thái 2) phải được focus
            + Ở đây ta sử dụng hook DidUpdate (tự động chạy khi vừa có 1 state được thay đổi) để xử lý (để bên component)
            + Tham số thứ nhất là gọi tới phần tử đó và focus vào nó
            + Tham số thứ hai là State vừa được thay đổi 
        => Nội dung không được để trống 
            + Ta sẽ xử lý khi người dùng nhấn enter: thay vì chỉ gọi hàm cập nhật trạng thái ==> ta sẽ kiểm tra 
             1. Nếu bằng rỗng ==> cập nhật lại nội dung (vd: "Tiêu đề không được để trống!")
             2. Nếu khác rống ==> Cập nhật trạng thái như bình thường 
            +Ta sẽ xử lý khi người dùng click chuột ra bên ngoài (xử lý tương tự như khi nhấn enter)
    Lưu ý: Nếu ta để thẻ input trong form thì khi ta nhấn enter nó sẽ reload lại trang (submit) nên khi xử lý bài này ta không đặt nó trong Form
-->

<!-- random là một phương thức nên khi sử dụng ta viết dưới dạng như sau Math.random()  -->

<!-- 
REDUX(là 1 giải pháp để ta xử lý 1 số trường hợp)
    => Xử lý khi có các component lồng trong nhau (vd-- app -> (A->(B->(C))))--) theo như cách cũ nó sẽ truyền lần lượt 
    => Khi xử lý như vậy sẽ có 1 số vấn đề xảy ra nếu ta cập nhật sửa đổi các chức năng (lúc đó ta sẽ phải code lại hết)
        - Khi ta phát triển, mở rộng thêm tính năng.(vd-- app -> (A->(new->(B->(C)))))--) khi đó nó sẽ bị đứt gãy vì A không thể truyền tới B
        - Khi ta bỏ đi 1 vài tính năng mà do đó bỏ đi component B. (vd-- app -> (A->...(C)))--) khi đó nó sẽ bị đứt gãy 

    Cấu trúc redux:  view->action->dispatcher->reducer->state->view
    1. view: hiển thị giao diện
    2. action: sự kiện
    3. dispatcher: nhận sự kiện từ bên ngoài => phân loại => đưa vào trong store cho reducer xử lý (vd: người dùng click chuột vào bình luận)
    4. reducer: các giải thuật xử lý 
    5. state: nhận giá trị kết quả tính toán từ reducer và đưa ra ngoài view (nhánh còn lại là gán lại giá trị vừa xử lý lại để sau này có thể sử dụng tiếp)
    => Có thể có nhiều reducer
    => Mỗi reducer sẽ xử lý các sự kiện có cùng chức năng (vd: chức năng tìm kiếm, bình luận)

    Để làm việc với REDUX ta cài 2 package (vào thư mục của react đang làm) và bật git terminal 
    - npm i redux cài redux
    - npm i react-redux (cái này là để nó kết nối redux với react)
    - ta import creatStore redux vào file store để sử dụng (để tạo store từ thư viện redux)
    - ta export default strore; (để thằng nào cần dùng thì nó gọi vào)
    - ta import name_store vào App (Đặt tên tùy ý nhưng thường đặt là store để dễ kiểm soát)
    - ta import Provider vào App (liên quan đến việc kết nối giữa redux và react) nó sẽ chụp lấy toàn bộ cái App 
    Minh họa:
    return (
        <Provider store={name_store}>
            ...
        <Provider/>
    )
    ==> viết như này nghĩa là ta đang cung cấp name_store cho toàn bộ cái App
    có thể có nhiều reducer nhưng chỉ có 1 store
-->

<!-- 
    *Trong ES6 ta có 1 cái cú pháp rất quan trọng
        obj = {
            a:a,
            b:b
        }
        newObj = {...obj, c:c} 
        => ... tương đương với việc lấy tất cả phần tử bên trong obj 
        => c:c là phần tử mới sẽ đè lại
    
    Ditpatch là biến toàn cục thế nên ta phải đặt các key khác nhau 
-->

<!-- 
    React Js là 1 framework của React 
    Khác biệt:
    => React là render html trực tiếp ở trên trình duyệt (client)
    => React Js là nó render qua 1 con server ở trên server rồi nó mới trả về html ở trên trình duyệt
    - Ưu điểm là có 1 số tính năng ở bên ngoài rất hay
    - Nhược điểm là chậm hơn 1 tý nhưng không đáng kể 
    Những ứng dụng mà muốn SEO mà dùng js thì rất khó (ta nên bỏ luôn Js đi ==> dùng php, wordpress)
    Nếu muốn trải nghiệm công nghệ mới thì dùng React Js
    GG nói luôn là không ưu tiên các website có hiệu ứng Js (nên nếu có Js nó sẽ hạ thứ bậc SEO)
    Nếu vẫn muốn dùng JS mà SEO tốt hơn thì ta dùng Next Js (nhưng vẫn không bằng PHP) nhưng cài đặt rất phức tạp 
-->

<!-- Quy tắc là nó sẽ tự gọi thằng nào có tên là index. -->

<!-- 
BÀI 9: ROUTER
    => Router là 1 phân đoạn trên URL
    => MỖi Route sẽ quyết định hiển thị nội dung tương ứng
    => Cài để làm việc với Route ==> < npm install react-router-dom >
    => import {BrowserRouter, Routes, Route, Link} để sử dụng 
        - Nếu ứng dụng của chúng ta cần sử dụng BrowserRouter thì phải đặt trong môi trường của nó (<BrowserRouter>...<BrowserRouter/>)
        - Ta sẽ có vùng làm việc với Routes (<Routes>...</Routes>) gồm rất nhiều Route
            Minh họa: 
                <BrowserRouter>
                    <Routes>
                        <Route path="/" element={<Home/>}></Route>
                        <Route path="/Contact" element={<Contact/>}></Route>
                        <Route path="/About" element={<About/>}></Route>
                    </Routes>
                </BrowserRouter>
            Route có 2 thuộc tính:
                - Thuộc tính thứ nhất path: là phân đoạn Route
                - Thuộc tính thứ hai là hiển thị nội dung tương ứng với phân đoạn Route ở thuộc tính thứ nhất 
            Khi nguời dùng nhập 1 phân đoạn route không có trong trang Web => ta sẽ xử lý như sau <Route path="*" element={<Page/>}/>
            * ở đây là tất cả những gì không phải là phân đoạn Route mà không có trong trang web của chúng ta
            Nguyên tắc của tải lại là toàn bộ nội dung trên này sẽ tải lại hết. Khi đó thì ta sẽ mất hết React vì React là thay đổi bất đồng bộ
            vì component nào thay đổi thì component đó được tải lại thôi chứ trang không reload ==> khi đó ta không sử dụng thẻ a nữa mà thay vào đó 
            ==> ta sử dụng thẻ Link (<Link to="...">...</Link>)

            Tất cả các trong trong dự án cho vào thư muc -- pages --

            Tất cả các thành phần dùng chung trên 1 dự án cho vào thư mục -- shared --
            vd: menu ta cho vào thư mục layouts nằm trong thư mục shared 

            Lưu ý: 
            - Thẻ Link viết hoa chữ cái đầu
            - Khi ta không muốn tải lại trang ==> Sử dụng thẻ Link
            - Khi muốn tải lại trang ==> sử dụng thẻ a
        -->

<!-- 
    BÀI 10: API là các cái link dưới dạng Json
        Cài npm i axios
        import axios vào file App.js để đọc và thao tác với API

        Lấy API:
        C1: dùng then
        const fetchData = () => {
            axios.get("https://....") ==> link API để đọc API
                .then(({data})=> { ==> trả về dữ liệu thông qua phương thức then (nó sẽ trả về 1 obj gồm 1 cái key là data (dữ liệu mà ta muốn lấy))
                    ...
                });
        }
        fetchData(); ==> Chạy phương thức lấy Data

        C2: Không dùng then (không khuyến khích sử dụng, thường sử dụng trong node)
        const fetData = async () => {
            const reponse = await axios.get("https://...");
            ...
        }
        fetchData();

        Thêm sửa xóa đối vối frontend rất ít 
        => chủ yếu là liệt kê

        Ngày trước khi request được gửi lên server => server sẽ lấy data và trả về 1 cái view và chúng ta phải viết rất nhiều backend khác nhau trên từng thiết bị (trên app, web)
        API
        Bây giờ người ta không trả dữ liệu thông qua backend (có rất nhiều ngông ngữ khác nhau) trả về view nữa (người ta không trả data bình thường nữa) mà trả về data được lưu dưới dạng Json 
        (vì Json thì tất cả các loại thiết bị đều có thể đọc được)

        Style code 
        Nguyên tắc là tên các component phải viết hoa các chữ cái đầu
        Nếu bên trong 1 thư mục component chỉ có file index thì chữ các chữ cái đầu của tên thư mục phải viết hoa 
        Nếu trong 1 thư mục component là file có tên không phải index thì tên thư mục viết thường và tên file viết hoa các chữ cái đầu

        Các dữ liệu lấy từ API đa phần lưu vào State để có thể thay đổi cũng như truyền dữ liệu từ con này sang con kia 
        Sử dụng hook DidMount để giao diện được tải lên hoàn toàn thì khi đó nó mới tự động lấy dữ liệu từ API 
-->
        
<!-- 
    BÀI 11

        Để lọc thông tin trả về ta sử dụng 1 biến config 
        Vd Minh họa 
        const ..config = { ==> Đặt tên tùy ý nhưng thường đặt là config
            prams: {
                id: ... , ==> Có thể là một mảng (id: [1, 3, 5])
            },
        }
        axios.get("https:....", config).then(({data})=>....)

        Trong shared có thư mục constants bên trong có file app.js chứa những hằng số không thay đổi (config) và sử dụng cho toàn dự án (vd: link API)
        VD => export const BASE_API = "https://json.../";
        Trong thư mục services có 2 file là Api.js và Http.js được sử dụng để gọi và xử lý API cho toàn bộ dự án 
        thứ tự xử lý 3 file trên là: (--App.js => Http.js => Api.js--)

        lưu ý: export là định nghĩa 1 file để các file khác có thể gọi vào sử dụng bằng câu lệnh import để sử dụng 
        => -- export default -- là định nghĩa 1 file 
        => Để định nghĩa nhiều file ta -- export -- từng cái 1  
        => -- import -- là gọi 1 file vào để sử dụng 
        => Để gọi nhiều file ta import và thêm cặp dấu ngoặc nhọn và viết hết trong đó (-- import {... , ... , ...})       
-->

<!-- 
    BÀI 13
    Thực tế khi ta thấy các phần có cấu trúc giống nhau ta cắt riêng nó ra cho vào 1 component để có thể dễ dàng sửa đổi (thay vì phải vào từng page 1 để sửa từng cái 1 thì ta sẽ chỉ sửa 1 file đó thôi)
    product-item.js => được sử dụng để lưu cáu trúc của 1 sản phẩm (khi sản phẩm thay đổi cấu trúc thì ta chỉ sửa cấu trúc trong file này thôi)
    ultils > index.js => ta có thể viết một số hàm trong này (nó gần giống như 1 thư viện để có thể sử dụng chung cho nhiều trang)

    => Khi ta lưu ảnh trên 1 server khác thì ta vào App.js để config lại server
    => Khi ta lưu ảnh trên 1 thư mục khác thì ta vào ultils > index.js để config lại thư mục ảnh

 -->

 <!-- 
BÀI 14:
    Để làm 1 cái menu ta có hai cách:
    C1: Vào trực tiếp file Menu.js rồi gọi API vào (fig cứng) => có 1 hạn chế xảy ra khi làm cách này là nếu menu này nó được di chuyển đi chỗ khác 
    C2: Gọi API vào file App.js rồi sử dụng prop để cho file nào cần (ở đây là file Menu.js) cách này khắc phục được hạn chế ở cách 1 

    => Kinh nghiệm: Nếu có data nào mà dùng cho nhiều component thì data đó sẽ lấy ở App.js (vì từ App ta có thể đẩy đi tất cả các con)

    => Reactjs liên tục cập nhật và có thể thay đổi cú pháp ==> Để sử dụng dự án này ta tiến hành cài đè lại phiên bản mới nhất bằng phiên bản 6.4 (npm i react-router-dom@6.4)

    => Trả về nhiều sản sẽ là trả về dưới dạng mảng => Trong mảng sẽ có nhiều object là các đối tượng => Trong object sẽ là các thông tin của đối tượng đó

    => Trả về duy nhất 1 sản phẩm là object

    Giá trị ban đầu của State
    => Với text là null
    => Số là 0 
    => Mảng là null

    Dính tới null trong State thì ta fix bằng cách thêm dấu ? (vd: category?.name) hoặc có thể thay null bằng rỗng (vd: [], "") thì sẽ không phải sử dụng toán tử dấu ?
    => vì ở đây reacjs là sử lý bất đồng bộ useEffect đang tải data nên thì category.name bên dưới đã chạy rồi thế nên mới xuất hiện lỗi với null

    =>  `...` phải đặt trong cùng làm việc của Js => {`...`}

    Format lại thời gian bình luận (của node js)
    => Ta cài module (npm i moment) 
    ==> Lấy thời gian cách đây bao lâu => 
            const day = moment("2021-06-30").fromNow();
    ==> Lấy giờ hiện tại 
            const day = moment();
    ==> Chuyển string sang ngày tháng
            const day = moment("2021-06-30");
    ==> Chuyển String sang ngày tháng + Format
            const day = moment("2021-06-30","MM-DD-YYYY");

    => Show ra dùng map
    => Show ra mà loại bỏ 1 số thằng thì fin
    => Kèm theo tính toán thì là reduce

    => post luôn luôn là thêm sản phẩm và có 3 tham số là id, data và config trong đó data luôn luôn là tham số thứ hai 
        vd: thêm bình luận 
            export const createCommentProduct = (id, data, config) => {
                return Http.post(`products/${id}/comments`, data, config);
            }

    Dựa vào từng dự án mà bên Backend quy định: 
    data phải là 1 obj:
    => các key truyền vào phải là name, email, content (key phải là đúng tiêu chuẩn)

    => Khi ta bấm nút submit trang sẽ tải lại. Để khắc phục điều này ta có hai cách:
     - thay submit bằng button
     - Loại bỏ hiệu ứng submit ==> sử dụng đối tượng e.preventDefault();

    .then là chúng ta sử dụng promise nên nó đợi

    LƯU Ý: Ở phần này ta sẽ gặp 1 số bug: 
     - khi ta nhấn submit thì form phải được clear
       => ở đây ta xử lý bằng cách: nếu data được push thành công thì ta sẽ gán lại giá trị cho nó bằng 1 obj rỗng (1 obj rỗng thì đối với dự án này ngta yêu cầu comment gửi đi là 1 obj)
       => và thuộc tính value tại mỗi thẻ input là: value = {inputComment.email.. || ""} tức là nếu nó có giá trị thì ta sẽ hiển thị giá trị ngược lại ta hiển thị 1 chuỗi rỗng
     - Khi ta submit thì phần bình luận phải được hiển thị (bug ở đây là khi ta submit thì bình luận sẽ không được cập nhật luôn mà ta phải enter lại url thì bình luận mới được cập nhật)
        => Lỗi này là do khi component reload lại (tức là thay đổi id) thì useEffect mới chạy khi đó nó mới thực hiện cập nhật lại comment (getCommentProduct())
        Cách xử lý có 2 cách:
         + ta viết 1 hàm để tạo ra 1 số random, gọi hàm đó vào tham số thứ hai của useEffect và mỗi khi ta click vào nút submit thì sẽ gọi tới hàm đó để tạo ra 1 số ngẫu nhiên
         + ta tách riêng getcommentProduct ra ngoài và gọi vào trong useEffect, tiếp theo gọi nó vào hàm onClickSubmit (lưu ý: không cho vào trong if)

    => Ở dự án này người ta phân trang comment nên nó chỉ hiển thị được 10 comment => nếu muốn test thì sang mấy trang có dưới 10 comment
-->

<!-- 
BÀI 16:
    useNavigate (Đây là 1 hook tự động chuyển hướng tới router khác khi ta đã thực thi xong các câu lệnh ở bên trên)
    vd Minh họa: 
            const navigate = useNavigate();
            return navigate("/Success");
    useParams (Đây là cách thức nhận các tham số ở trên Route thông qua :id) Lưu ý: cần có Route để nhận (Nó sẽ nhận từng phân đoạn Route)
    => Muốn truyền mà không cần Route để nhận ta sử dụng query string (không ảnh hưởng gì tới cấu trúc của Route)
    VD Minh họa:
    ...?name= NguyenVan A&age= 20 
    => với phần đằng sau dấu hỏi được gọi là query string 
    => Ta sử dụng useSearchParams để nhận (sử dụng gần giống như State)
    vd Minh họa:
    const [searchParams, setSearchParams] = useParams();
    setSearchParams(
        {
            name: "VietPro",
            email: "a@gmail.com"  //(theo kiểu key:value)
        }
    )
    searchParams.get("name"); //==> VietPro
    => Tham số thứ nhất .get("..keyName..") ==> ra value tương ứng với key đó
    => Tham số thứ hai khi được gán lập tức nó sẽ  được đẩy lên URL (hoạt động gần giống như tham số thứ 2 của State) 
    (lưu ý: Tham số thứ nhất .get() là lấy từ trên URL xuống)

    => Để xây dựng chức năng tìm kiếm ta dùng Elasticsearch

    => Ở đây nút tìm kiếm là submit. Khi ta nhấn nó sẽ reload lại trang => Reacjs của ta sẽ bị mất đi vì vậy ta sử dụng e.preventDefault(); => Để ngăn chặn hiệu ứng submit

    Phát hiện mới: Vì database không phân biệt chữ hoa chứ thường (vd như khi tên tất cả sản phẩm đều là IPhone nhưng khi ta search iphone thì vẫn ra kết quả)
    Ở đây là không cần viết chính xác tên sản phẩm mới ra kết quả vì cái config (params) này nó không so sánh tuyệt đối chỉ cần có 1 hay vài kí tự liên tiếp nhau nó trùng trong chuỗi có key là name thì nó cũng sẽ hiển thị
    => Lưu ý: vì nó các kí tự cần phải liên tiếp nhau (liên tiếp nhau ở đây là liên tiếp về mặt thứ tự chứ không phải là các kí tự phải đứng ngay sát nhau)
    nên khi ta search 1 chuỗi (vd: name là "Nokia A9 Plus" mà ta search là Nokia Plus thì nó sẽ không thể hiển thị được sản phẩm)
    
    Các bước tạo nên chức năng thanh tìm kiếm code chay:
    
-->

<!--
Bài 17
    => useLocation là 1 Hook thuộc Module React Router cho phép chúng ta lấy thông tin từ URL hiện tại

    VD Minh họa: (ta có đường dẫn: http://location:3000/search?q=iphone&page=2293)
        const location = useLocation();
        location.pathname; //http://localhost:3000/search (phần route)
        location.search; ?q=iphone&page=2293 (phần query string)

    Lấy từng phân đoạn 1 trên URL sử dụng searchParams.get("..keyName..");
    Không thể nhúng Js vào chuỗi nên nếu vẫn muốn cả chuỗi cả js thì ta dùng string template => {`....`}
-->

<!-- 
BÀI 18:
    API localStorage cho  phép lưu trữ dưới dạng key-value trên máy của user (lưu tạm thời)
    Sử dụng:
     - localStorage.setItem('name', 'trieu'); => Lưu dữ liệu vào datastore (tham số thứ nhất là keyName, tham số thứ hai là value)
     - localStorage.getItem('name'); => Lấy dữ liệu từ datastore qua key là name
     - localStorage.removeItem('name'); => Xóa dữ liệu trên datastore với key là name
     - localStorage.clear(); => Xóa toàn bộ dự liệu đã lưu 

    Phương thức Reduce (được sử dụng khi ta có 1 mảng và cần tính toán các giá trị ở trong mảng hoặc cần nối các giá trị ở trong mảng)
     - Reduce không có tham số initialValue
        vd Minh họa:
            const data = [
                {qty:1},
                {qty:3},
                {qty:4},
                {qty:9}
            ]
            const result = data.reduce((total, item)=> {
                return total + item.qty;
            })
        => Ở đây vì không có tham số initialValue nên total sẽ mặc định định được gán giá trị khởi tạo ban đầu là phần tử đầu tiên trong mảng (là 1 obj {qty:1})
        => Khi đó reduce sẽ không duyệt qua phần tử đầu tiên trong mảng nữa mà bắt đầu tử phần tử thứ 2. Kết quả trả về sẽ được lưu vào biến total.
        => Vì giá trị khởi tạo không phải là số (1 obj) nên reduce nó sẽ hiểu là nối chuỗi ==> Khi đó kết quả cuối cùng được trả về là {qty:1}349
        Như vậy kết quả trả về sẽ không đúng với dụng ý của người code. Khi đó ngta mới sinh ra Reduce có tham số inivialValue là tham số thứ 2 của reduce
     - Reduce có tham số inivialValue
        vd Minh họa: (cũng giống hệt như vd trên nhưng chỉ thay đổi 1 chút là có thêm tham số thứ 2)
            const result = data.reduce((total, item)=> {
                return total + item.qty;
            }, 10)
        => Ở đây thay vì lấy giá trị khởi tạo là phần tử đầu tiên trong mảng như ở tham số thứ nhất thì nó sẽ lấy 10 là giá trị khởi tạo của total
        => Và bắt đầu duyệt lần lượt các phần tử ở trong mảng ==> Khi đó đây là phép tính toán nên kết quả trả về cuối cùng là: 10+1+3+4+9 = 27

        Giỏ hàng ở đây là lưu tạm thời và ta sẽ lưu vào cả redux và localStorage (lưu song song)
         - Lưu vào redux:
            + Ưu điểm: dễ dàng phân phối tới các component
            + Nhược điểm: tất cả các component bị reaload lại dẫn tới sẽ bị mắt thằng store
         - Lưu vào localStorage:
            + Nhược điểm: Khó khăn hơn khi phân phối tới các component
            + Lưu trên này mãi mãi

    Nguyên tắc của Map là phải có return trả về

    import { Provider } from "react-redux";
    import {useDispatch} from "react-redux";
    Hêm nay tôi gặp 2 lỗi này khi bấm vào gợi ý của nó. Tôi đang làm việc với redux thay vì nó gợi ý là "react-redux" thì nó lại chỉ gợi ý mỗi là react thế nên tôi dính chưởng
-->
 
<!-- 
BÀI 19:
    Kiến thức bổ trợ: ta có vòng lặp filter() trả về các phẩn tử đã được sàng lọc (ta có thể không cẩn sử dụng filter mà có thể dùng map và thêm các điểu kiện if-else để lọc)
    VD Minh họa: Lọc ra các phần tử chẵn
        const arr = [1, 2, 3, 4, 5, 6];
        const new_arr = arr.filter((value) => {
            return value%2==0;
        });

    Khi map thì chúng ta phải hỏi xem có chưa, có rồi thì ta mới bắt đầu đi map (carts?.map(...))
    export default thì import ...
    export thì import {...}
    Trả về giá tiền được format thành tiền Việt Nam
    => new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(number)

    Tất cả những gì mà người dùng nhập vào ở form thì nó đều hiểu là dạng chuỗi. Nên khi xử lý với số ta phải ép kiểu
    => Kinh nghiệm: khi ta sử dụng map để lấy ra kết quả thì ta nên gán nó vào 1 cái biến rồi lấy ra kết quả chứ không lấy sẵn của nó
    ==> Vì nó là 1 copack function nên nó chưa kịp xử lý xong thì câu lệnh return bên dưới đã chạy rồi (Đây là xử lý bất động bộ vì copack function khi đó sẽ chạy chậm hơn
    đồng nghĩa với việc kết quả chưa được xử lý xong thì return đã chạy và kết quả return ra ở đây là kết quả cũ)
    ==> Nên khi ta gán nó vào 1 cái biến rồi sử dụng cái biến đấy để return thì đây lại là xử lý đồng bộ vì khi đó return sẽ phải đợi cái biến đó được tính toán xong mới tiến hành trả về

    Khi sử dụng confirm() thì khi thông báo được hiển thị lên: 
     - Người dùng bấm đồng ý thì nó trả về true
     - Người dùng bấm quay lại thì nó trả về false
    Khi gán confirm bằng 1 biến và sử dụng trong 1 hàm nào đó thì nó sẽ báo lỗi vì đây là biến toàn cục => Khi đó ta có thể fix lỗi này bằng cách đặt đoạn sau ở trên ( //eslint-disable-next-line no-restricted-globals)

    Lưu ý: mỗi khi ta bấm vào thẻ a thì nó nhảy lên đầu trang bởi vì nút a có hiệu ứng tải lại trang (submit) ==> Để loại bỏ sử dụng e.preventDefault
    
    Khi chúng ta list dữ liệu ra thì then thường là data.data.docs
    Còn khi ta post thì thường là data.keyname với keynam là để báo cho chúng ta đã push dữ liệu thành công hay lỗi

    Khi ta return ra 1 object mà muốn viết tắt thì ta thêm cho nó cặp dấu ngoặc tròn (bởi vì nó sẽ bị hiều nhầm cặp đấu ngoặc nhọn đó)

    Khi ta gặp lỗi về API như post thông tin thì ta vào phần network -> Nếu thầy lỗi 400 tức là gửi đi bị thât bại 
    => Để check chi tiết ta bấm vào all -> response

    Lưu ý: Để tránh người dùng quen tay nhấn enter URL (Khi đó ta sẽ mất hết React js ) => Ta sẽ cài 1 module -- npm i redux-persist --
    Mỗi khi ta lưu 1 dữ liệu vào localStorage nó sẽ lưu vào storage 
    Để sử dụng ta phải cấu hình nó: 
        const persistConfig = {
        key: "redux-store", //=> Điền gì cũng được (giúp bảo mật hơn)
        storage: storage, //=> Sử dụng key là storage để lấy storage của nó
        keyPrefix: "vietpro:", //=> Điền gì cũng được( giúp bảo mật hơn)
        }
        const store = createStore(persistReudcer(persistConfig, reducers)); //=> Lấy xuống
        persistStore(store); //=> Lưu lên (Khi 1 component thay đổi thì store thay đổi khi đó nó sẽ lưu lại)
    Lưu ý phải để dưới reducer
}

 -->
